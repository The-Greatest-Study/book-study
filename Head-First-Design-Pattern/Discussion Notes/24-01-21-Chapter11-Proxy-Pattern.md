# 프록시 패턴(Proxy-Pattern)
- 접근을 제어하고 관리하는 역할

## [STEP1] 모니터링 코드 만들기
- 모니터링 : 모든 뽑기 기계의 재고와 현재 상태를 알려주는 기능 추가 요청
    - 모니터링 클래스(현재 상태에 대한 리포트 추가) 추가
    - 리포트에서 현재 상태에 대한 출력

- 원격 프록시 필요
    - GumballMonitor 클래스의 프록시를 레퍼런스로 넘겨주자
    - 프록시 객체의 레퍼런스를 받아 오는 기능을 추가
    - 다른 공간에 있는 객체에 대해서 원격 프록시가 호출된 메소드를 전달해준다. (프록시는 원격객체의 탈을 쓴 전달 매개체)

## [STEP2] 모니터링 코드에 원격 프록시 추가하기
- 그래서 다른 공간에 있는 객체 레퍼런스를 가져오는 방법은..?
    - 자바의 원격메소드 호출(RMI)
        - [RMI란?](https://velog.io/@kipsong/RMI-JMeter-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8B%A4%EA%B0%80-%EC%A0%95%EB%A6%AC)
        - 자바 RMI는 이 Client와 Service의 보조객체를 만들어 준다.
        - 원격 객체 접근시 lookup 메소드를 제공
        - 로컬 호출과 RMI 호출에는 네트워크 차이가 있기 때문에 대비가 필요
            - RemoteException

    - 원격 서비스 만들기
        1. 원격 인터페이스 만들기
            - Remote Exception 처리
            - 원격 메소드의 인자와 리턴값은 Primitive or Serializable 이어야 한다.
                - 네트워크로 전달되어야 하기 때문
                - [직렬화는 어디에 사용?](https://velog.io/@sa1341/Java-%EC%A7%81%EB%A0%AC%ED%99%94%EB%A5%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C#4-%EC%A7%81%EB%A0%AC%ED%99%94%EB%A5%BC-%EC%A3%BC%EB%A1%9C-%EC%96%B4%EB%94%94%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80)
                    - 자주 변경되는 비즈니스적인 데이터를 Java 직렬화을 사용하지 않는다.
        2. 서비스 구현 클래스 만들기
        3. RMI 레지스트리 실행하기(여기서 RMI스텁을 가져감)
        4. 원격 서비스 실행하기

## 프록시 패턴의 정의
- 특정 개체로의 접근을 제어하는 대리인(특정 객체를 대변하는 객체)를 제공합니다.
- 프록시에서 접근을 제어하는 방법
    1. 원격 프록시를 써서 원격 객체로의 접근을 제어가능
    2. 가상 프록시를 써서 생성하기 힘든 자원으로 접근을 제어
        - 가상 프록시란? 생성하는데 많은 비용이 드는 객체 대신
        - 변종 : 캐싱 프록시(기존 생성 객체들을 캐시에 저장했다가 요청이 들어왔을 때 리턴가능)
    3. 보호 프록시를 써서 접근 권한이 필요한 자원으로의 접근을 제어
- 데코레이션 패턴과 비교
    - [데코레이션 패턴]은 새로운 행동을 추가하는 용도이나, [프록시 패턴]은 어떤 클래스로의 접근을 제어하는 "용도의 차이"
- 어댑터 패턴과 비교
    - 공통점은 클라이언트와 다른 객체 사이에서 클라이언트의 요청을 다른객체에게 전달하는 역할을 한다는 것
    - [어댑터 패턴]은 다른 객체의 인터페이스를 바꿔주지만 [프록시 패턴]은 똑같은 인터페이스를 사용한다.

## 보호 프록시 만들기
    - 동적 프록시(실행중에 생성)
    - 접근 권한을 바탕으로 객체로의 접근을 제어하는 프록시
