# Chapter 11. 시스템

## 도시를 세운다면

- 깨끗한 코드로 도시의 기능들처럼 소프트웨어도 관심사 분리나 추상화를 할 수 있을까?

## 시스템 제작과 시스템 사용을 분리하라

- 대다수는 관심사 분리를 하지 않는다.

  - 실제로 필요할 때까지 객체를 생성하지 않음 -> 의존성 해결하지 않으면 컴파일x

- 테스트 시에도 런타임 로직에 객체 생성이 있어서 단일 책임 원칙에 위배됨
- Main분리, 팩토리: 생성과 관련된 코드를 어플리케이션과 분리한다
- 의존성 주입: 전담하는 메커니즘에 책임을 넘겨 단일 책임 원칙을 지킨다.
  - 클래스는 수동적이기에 setter나 생성자 인수 제공
- 자바 DI 컨테이너: 객체사이 의존성을 xml파일에 정리

## 확장

- 소프트웨어 시스템은 관심사의 분리를 하지않으면 확장이 어렵다.
- 횡단(cross-cutting) 관심사
  - 현실에서는 영속적으로 구현한 코드가 온갖 객체로 흩어짐.
  - AOP(Aspect-Oriented Programming)에서 "특정 관심사를 지원하기 위해서는 특정 지점들이 동작하는 방식을 일관성있게 바꿔야한다" 라고 명시

## 자바 프록시

- 단순한 상황에 적합
- 코드의 양과 크기가 크므로 클린 코드가 되진 않는다

## 순수 자바 AOP 프레임워크

- 내부적으로 프록시를 사용
- 스프링은 비즈니스 논리를 POJO로 구현. POJO는 다른 도메인에 의존하지 않는다.
- 애플리케이션에서 DI 컨테이너에게 객체요청
  - 스프링관련 자바코드가 거의 필요하지 않음(스프링과 독립적)
  - 횡단 관심사를 선언적으로 지원하는 스프링 모델로 진화

## 테스트 주도 시스템 아키텍처 구축

- 단순하게 잘 분리된 아케텍처로 결과물을 빨리 출시한 후 기반 구조를 추가하며 조금씩 확장

## 의사 결정을 최적화하라

- 가장 적합한 사람에게 책임을 맡겨라
- 최대한 정보를 모아 결정하기 위해, 가능한 마지막 순간까지 결정을 미루는 방법이 최선

## 명백한 가치가 있을 때 표준을 현명하게 사용하라

- 표준이라는 이유로 과도하게 사용에 집착하지 말자

## 시스템은 도메인 특화 언어가 필요하다

- 좋은 DSL(Domain-Specific Language), 도메인 개념간의 의사소통 간극을 줄여준다.

---

### 결론?

- 명확한 도메인 논리로 깨끗한 아키텍처를 구현해야 좋은 시스템이 될 수 있다.
- 실제로 돌아가는 가장 단순한 수단을 사용해야 한다!

---
