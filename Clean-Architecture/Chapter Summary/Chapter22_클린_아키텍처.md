### 클린 아키텍처의 특징: 관심사의 분리
- **프레임워크 독립성**: 프레임워크가 지닌 제약사항 안으로 시스템을 맞추도록 강제하지 않는다.
- **테스트 용이성**: 업무 규칙은 외부 요소가 없어도 테스트를 진행할 수 있다.
- **UI 독립성**: 시스템의 타 부분을 변경하지 않고도 UI를 쉽게 변경할 수 있다.
- **데이터베이스 독립성**: 업무 규칙은 데이터베이스의 특성에 결합되지 않는다.
- **외부 에이전시에 대한 독립성**: 업무 규칙은 외부 세계의 인터페이스에 대해 전혀 알지 못한다.

### 의존성 규칙
> 소스코드 의존성은 저수준 -> 고수준으로 향해야 한다.
> 프레임워크와 드라이버 (저수준) -> 인터페이스 어댑터 -> 유스케이스 -> 엔티티 (고수준)

#### 1. 엔티티
- 전사적인 핵심 업무 규칙을 담고있다
- 그러므로 가장 변경될 여지가 적고, 고수준인 규칙을 캡슐화 한다

#### 2. 유스케이스
- 애플리케이션에 특화된 업무 규칙, 시스템이 이루어야 하는 모든 유스케이스를 캡슐화 하고 구현한다
- UI, 프레임워크 변경에는 영향을 받지 않지만, 애플리케이션이 변경된다면 해당 계층에 영향이 있다

#### 3. 인터페이스 어댑터
- 엔티티 / 유스케이스의 데이터를 -> 데이터베이스 / 웹등 외부에 전달하기 편한 형식으로 변환한다
- Ex) Presenter, View, Controller

#### 4. 프레임워크와 드라이버
- 데이터베이스, 웹 프레임워크와 같은 도구들로 구성된다
- 애플리케이션의 로직과의 직접적인 관계는 거의 없다

### 경계 횡단하기
> 제어의 흐름: 안 -> 밖 (고수준 -> 저수준)
> 	데이터의 흐름이 안에서 밖으로 가면서 애플리케이션에서 보여지게 된다
> 의존성 흐름: 밖 -> 안 (저수준 -> 고수준)
> 	의존성의 방향은 반대이다: 저수준의 코드에서는 고수준의 코드를 호출할 수 있지만, 고수준의 코드에서는 저수준의 코드에서 정의된 항목을 언급하면 안된다


#### 결론
- 의존성 규칙을 준수한다면
	- 테스트 하기 쉬운 시스템이 된다
	- 쉽게 DB나 프레임워크를 교체할 수 있다