여러 개발자가 협업하는 환경에서 코드의 지속적인 변경사항을 반영하기는 쉽지않다.
이런 문제점을 해결하기 위한 두가지 방법으로 주 단위 빌드와 의존성 비순한 원칙을 활용할 수 있다.

### 주 단위 빌드 (Weekly Build)
- 주 4회 (월 ~ 목)까지 개별적으로 코드의 수정사항 반영
- 주 1회 (금) 모든 코드를 합치는 작업 진행
- 장점: 주 4일은 독립적으로 작업 가능
- 단점: 프로젝트의 규모가 커지면서 도입하기가 더 어려움 (빌드하는데 시간이 더 오래걸림)

### 의존성 비순환 원칙 (Acyclic Dependencies Principles)
- 컴포넌트 간의 의존성 그래프는 순환되어서는 안된다
- 순환을 없애기 위해서는 순환참조가 되는 컴포넌트를 추상화 하여 양쪽 컴포넌트가 둘다 추상화 클래스를 바라보도록 변경해야한다
- 장점: 특정 컴포넌트를 개발하는 개발자는 해당 컴포넌트가 의존하고 있는 다른 컴포넌트가 릴리즈 되었을때, 해당 컴포넌트를 도입할 시기를 스스로 결정할 수 있다


<hr>

### 안정된 의존성 원칙 (SDP)
- 덜 안정적인 컴포넌트가 (변경될 가능성이 많음) 더 안정적인 컴포넌트에 (변경될 가능성이 적음) 의존해야한다

##### 안정성 지표
- Fan-in: 내부로 들어오는 의존성, 내가 의존하고 있는 다른 컴포넌트의 갯수
- Fan-out: 외부로 나가는 의존성, 나에게 의존하고 있는 다른 컴포넌트의 갯수
- I = Fan-out / (Fan-in + Fan-out) -> 이 수치가 0일수록 안정적, 1일수록 불안정적

### 안정된 추상화 원칙 (SAP)
- 컴포넌트는 안정된 정도만큼 추상화되어야 한다 -> 손쉽게 확장 가능
- SDP에 의하면 안정성 -> 추상화를 의미한다 

##### 추상화 정도 측정
- Nc: 컴포넌트 클래스 갯수
- Na: 컴포넌트의 추상 클래스와 인터페이스 갯수
- A = Na / Nc -> 이 수치가 0일수록 덜 추상화, 1일수록 더 추상화