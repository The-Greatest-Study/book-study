# Item 18. 상속보다는 컴포지션을 사용하라

## 상속
- 상속은 코드를 재사용하는 강력한 수단이지만, 항상 최선은 아니다. 잘못 사용하면 오류를 내기 쉬운 소프트웨어를 만들게 된다. 
- 상속은 캡슐화를 깨트린다.
- 상속은 반드시 하위 클래스가 상위 클래스의 ‘진짜’ 하위 타입인 상황에서만 쓰여야 한다.
  (= 클래스 B가 클래스 A와 is-a 관계일 때만 클래스 A를 상속해야 한다.)

## 상속으로 인한 오동작 예시
- 메서드 재정의
  - 상위 클래스는 릴리스마다 내부 구현이 달라질 수 있으며, 그 여파로 코드 한 줄 건드리지 않은 하위 클래스가 오동작할 수 있다.
    ```java
    public class InstrumentedHashSet<E> extends HashSet<E> {
            private int addCount = 0;
            
            @Override public boolean add(E e) {
                    addCount++;
                    return super.add(e);
            }
            
            @Override public boolean addAll(Collection<? extends E> c) {
                    addCount += c.size();
                    return super.addAll(c);
            }
            
            public int getAddCount() {
                    return addCount;
            }
    }
    ```
  - InstrumentedHashSet 클래스의 addAll 메서드 호출 시,
  - addCount가 증가한 뒤 HashSet의 addAll 메서드 호출이 되고,
  - 그 안에서는 InstrumentedHashSet에서 재정의된 add 메서드가 각각 호출되기 때문에 또 addCount가 증가된다.
  - ⇒ 3개의 원소를 가진 list를 addAll 메서드로 호출한 뒤 getAddCount()를 호출하면 6이 반환된다.
- 하위 클래스에서 새로운 메서드 정의
  - 다음 릴리스에서 상위 클래스에 새 메서드가 추가되었는데 운없게도 기존에 하위 클래스에 추가한 메서드와 시그니처가 같고 반환타입이 다르다면 컴파일도 되지 않는다.
  - 다음 릴리스에서 상위 클래스에 새 메서드가 추가되었는데 시그니처가 동일하고 반환타입마저 동일하다면 메서드를 재정의한 상황이 되어버리고, 위의 예시와 동일한 상황에 부닥친다.

## Composition
- 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하자. 
- 기존 클래스가 새로운 클래스의 구성 요소로 쓰인다는 뜻에서 이러한 설계를 컴포지션 (composition, 구성) 이라 한다. 
- 컴포지션을 써야 할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하는 꼴이다.
- forwarding (전달)
  - 새 클래스의 인스턴스 메서드들은 (private 필드로 참조하는) 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환
  - 그러한 메서드들을 전달 메서드(forwarding method) 라고 한다.
- wrapper class
  - 다른 클래스의 인스턴스를 감싸고 있는 클래스
  - wrapper 클래스는 단점이 거의 없지만, 콜백 프레임워크와는 어울리지 않는다.

## 컴포지션 대신 상속을 사용하는 경우 체크해야 하는 것
- 확장하려는 클래스의 API에 아무런 결함이 없는가?
- 결함이 있다면, 이 결함이 여러분 클래스의 API까지 전파돼도 괜찮은가?

컴포지션으로는 이런 결함을 숨기는 새로운 API를 설계할 수 있지만, 상속은 상위 클래스의 API를 ‘그 결함까지도’ 그대로 승계한다.

## 핵심 정리
상속은 강력하지만 캡슐화를 해치다는 문제가 있다.
상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야 한다.
is-a 관계일 때도 안심할 수만은 없는게, 하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제가 될 수 있다.
상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자.
특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 그렇다.
래퍼 클래스는 하위 클래스보다 견고하고 강력하다.