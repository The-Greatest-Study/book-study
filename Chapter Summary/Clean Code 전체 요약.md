# Clean Code 전체 요약

by Jihong

----

## 2장, 의미 있는 이름

소프트웨어에서 이름: 변수, 함수, 인수, 클래스, 패키지, 소스파일, 디렉터리, jar, war, ear 등 이름을 많이 사용

➡ 이름을 잘 정하는 것이 중요하다.

 

 

**1. 의도 밝히기**

 

변수, 함수, 클래스 등 이름을 지을 때 이름에 의도를 담아야 함

 

🔗따로 주석이 필요하면 의도를 드러내지 못한 것

 

> **생각해봐야 할 질문**
> \- 변수(or 함수 or 클래스)의 존재 이유는?
> \- 수행 기능은?
> \- 사용 방법은?

 

ex)

Bad Code

```
public List<int[]> getThem(){
 List<int[]> list1 = new ArrayLists<int[]>();
 for (int[] x : theList)
  if (x[0] == 4)
   list1.add(x);
  return list1;
}
```

\- 변수의 의미가 명확하지 않음

\- x[0]의 의미는? 4의 의미는? list1은 어떤 것을 담고 있는가?

 

 

Clean Code



![img](https://k.kakaocdn.net/dn/bli6cm/btrihKmXx9j/I5ko2ztfVpc2Kiep4Vlla0/img.jpg)이름을 명확하게 해서 사용하는 의미 밝히기



\- 위와 같은 코드이지만, 확실하게 각 변수들이 어떤 의미를 가지고 있는지 파악할 수 있음

 

 

 

**2. 잘못된 정보 피하기**

 

\- 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용❌

ex1) hp(직사각형 빗변), aix, sco ➡️ 본래 의미로 사용할 것

ex2) List: List 형식이 아니라면 잘못된 정보를 제공하는 것 ➡️ List 형식이 아닐 경우 Group, Acoounts 등으로 명명

 

\- 흡사한 이름 사용❌

ex) XYZControllerForEfficentHandlingOfStrings와 XYZControllerForEffcientStorageOfStrings의 차이점은?

 

\- 일관성 있는 표기법 사용

 

\- L과 O 주의 ➡️ 글씨체를 바꿔서 해결

💡 네이버 D2의 CodingFont 추천

 

 

 

**3. 의미 있는 구분**

 

\- 동일한 범위 안에서 다른 두 개념에 같은 이름을 사용하지 못함

ex) class를 사용하지 못해 klass 사용 등 의미 없는 철자를 바꿔서 구분

 

\- 연속적인 숫자(a1, a2, a3, ...): 정보 제공❌

 

\- 불용어(중복)를 추가한 이름: 정보 제공❌

ex) ProuctInfo와 ProductData는 개념을 구분하지 않고 이름만 다르게 사용함

 

 

 

**4. 발음하기 쉬운 이름**

**5. 검색하기 쉬운 이름**

 

\- 이름길이는 범위 크기에 비례해야 함

ex) const int WORK_DAYS_PER_WEEK = 5; 라는 변수는 5라는 상수를 검색할 때보다 쉽게 검색이 가능함

 

 

**6. 인코딩❌**

 

\- 발음하기 어려움, 오타 발생이 쉬움

 

\- 강한 타입(strongly-typed)인 자바의 경우, 클래스 이름을 바꾸어도 타입 이름을 바꾸지 않아도 됨

ex) PhoneNumber phoneString;

 

\- 멤버 변수 접두어: 클래스와 함수는 접두어가 필요 없을 정도로 작아야 함

ex) 기존에는 멤버 변수에는 m_ 접두어를 붙임

 

\- 멤버 변수를 다른 색상으로 표시하는 IDE 사용

 

\- 인터페이스 클래스와 구현 클래스: 구현 클래스 이름을 인코딩

ex) ShapeFactory(인터페이스 클래스) ShaeFactoryImp(구현 클래스)

 

 

**7. 기억력**

 

\- 명료함

 

\- 실제 아는 이름으로 변수 이름을 변환하면 좋지 않은 변수 이름

 

\- 문자 하나만 사용하는 변수의 경우 i, j, k까지만 허용

why? 루트 범위가 매우 작은 경우, 반복 횟수 변수를 주로 i, j, k를 이용하기 때문

 

 

 

**8. 클래스 이름**

 

\- 클래스 이름과 객체 이름은 명사나 명사구가 적합

ex) 적합한 이름: Customer, WikiPage, Account, AddressParser

↔ Manager ,Processor, Data, Info 등의 단어는 좋지 않음

 

 

 

**9. 메서드 이름**

 

\- 메서드 이름은 동사나 동사구가 적합

ex) 적합한 이름: postPayment, deletePage, save

 

\- 접근자(Accessor) - get , 변경자(Mutator) - set , 조건자(Predicate) - is는 javabean 표준에 따라 작성

ex) getName(), setName("Mike"), isPosted()

 

\- 생성자 중복정의(overload): 정적 팩토리 메서드 사용

ex) Complex fulcrumPoint = Complex.FromRealNumber(23.0);

Comple fulcrumPoint = new Complex(23.0); --> 해당 코드를 더 선호

 

 

 

**10. 기발한 이름❌**

**11. 한 개념에 한 단어 사용**

 

\- fetch, retrieve, get 등 같은 개념에 여러 단어 사용 시 혼란스러울 수 있음

 

\- 일관성 있는 이름 사용

 

 

 

**12. 한 단어를 두 가지 목적으로 사용❌**

 

\- 일관성 있는 목적

ex) add, insert, append ➡ 비슷한 뜻이지만 각각 다른 목적을 가지고 사용

 

 

**13. 해법 영역에서 가져온 이름 사용**

 

\- 프로그래머 용어(전산 용어, 알고리즘 이름, 패턴 이름, 수학 용어 등) 사용 ➡ 코드를 읽는 사람도 프로그래머이기 때문

 

 

 

**14. 문제 영역에서 가져온 이름 사용**

 

\- 코드를 보수하는 프로그래머가 분야 전문가에게 의미를 물어서 파악 가능하도록 함

 

 

 

**15. 의미 있는 맥락 추가**

 

ex) 주소를 나타내는 변수

Bad Code

firstName, lastName, street, houseNumber, city, state, zipcode ...

 

Clean Code

addrFirstName, addrLastName, addrStreet, addrHouseNumber, addrCity, addrState, addrZipcode ...

 

\- 의미를 가지는 접두어를 포함하여 맥락을 분명하게 함

 

 

 

**16. 불필요한 맥락❌**

 

\- Gas Station Deluxe 애플리케이션 작성 시 모든 클래스 이름을 GSD로 시작하는 것은 불필요한 맥락을 추가하는 것

 

\- 의미가 분명한 경우에는 짧은 이름을 사용



---

## 3장, 함수

함수를 처음 읽는 사람이 프로그램 내부를 직관적으로 파악 할 수 있어야 함

 

 

 

**1. 작게 만들기**

 

\- 얼마나 작게 만들어야 할까? ➡ 모든 함수를 4줄 이내로

🚧 if / else/ while 문 등에 들어가는 블록은 한 줄이어야 함

 

Clean Code

```
public static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) throws Exception{
    if(isTestPage(pageData)){
        includeSetupAndTeardownPages(pageData, isSuite);
    }
    return pageData.getHtml();
}
```

➡ if문 안에는 하나의 함수로 감싸져 있음

➡ 바깥 함수가 작아짐

 

 

\- 각 함수가 할 이야기는 명백하게 하나의 이야기만 표현

 

 

 

**2. 한 가지 처리만**

 

\- 한 가지가 무엇인지 알기 어려움

➡ 추상화 수준에서 여러 단계로 나눠서 수행이 가능한가?

➡ 의미가 있는 다른 함수로 추출할 수 있는가?

 

 

 

**3. 함수 당 추상화 수준은 하나**

 

\- 함수가 한 가지 작업만 하기 위해서는 모든 문장의 추상화 수준이 동일해야 함

➡ 근본 개념과 세부 개념이 뒤섞일 수 있음

 

\- 코드에 일관성이 생김

 

> 👀
>
>  
>
> 내려가기 규칙
>
> 코드가 위에서 아래로 이야기처럼 읽힐 때, 한 함수 다음에 추상화 수준이 한 단계 낮은 함수가 오는 것
>
> ```
> if(조건1){
>     if(조건2){
>     }
> }
> ```
>
>  
>
> ➡ 조건1의 내용은 조건2의 내용이 포함되어 있다.
>
> ➡ 조건2는 조건1보다 구체적인 추상화 내용을 담고 있다.

 

 

 

**4. Switch 문**

 

\- 다형성(polymorphism)을 이용하면 swtich 문을 반복하지 않을 수 있음

 

ex)

Bad Code

```
public Money calculatePay(Employee e) throws InvalidEmployeeType{
    switch (e.type){
        case COMMISSIONED:
            return calculateCommistionedPay(e);
        case HOURLY:
            return calculateHourlyPay(e);
        case SALARIED:
            return calculateHourlyPay(e);
        default:
            throw new InvalidEmployeeType(e.type);
    }
}
```

\- 함수의 길이가 김

\- 한 가지 작업만 수행하지 않음

\- SRP(Single Responsibility Principle)을 위반함

> SRP(Single Responsibility Principle): 단일 책임 원칙
> \- 모든 클래스는 하나의 책임만을 가지며, 클래스는 그 책임을 완전히 캡슐화 해야 함

\- OCP(Open Close Principle) 위반

> OCP(Open Close Principle): 개방-폐쇄 원칙
> \- 소프트웨어 개체는 확장에 대해 열려있어야 하고, 수정에 대해서 닫혀있어야 함

\- ⭐ 동일한 구조의 함수가 무한정 존재 할 수 있음

ex) isPayday(Employee e, Date date);

 

 

Clean Code



![img](https://k.kakaocdn.net/dn/qOWav/btriTvUX3Ja/LsHxGfa4VIMYzacGayg9b0/img.png)



\- 추상화 레벨로 상속 관계를 숨김

 

\- 단 한번만 switch문 사용 ➡ 다형성 객체 생성 코드에서만 사용

 

 

 

**5. 서술적인 이름 사용**

 

\- 코드를 읽으면서 짐작했던 기능을 각 루틴 그대로 수행하면 깨끗한 코드

 

 

 

**6. 함수 인수**

 

\- 인수가 적을수록 좋은 코드, 테스트도 쉬움

 

\- 출력 인수는 입력 인수보다 더 이해하기 어려움

 

\- 플래그 인수(boolean)는 사용하지 않는 것이 좋음

 

인수 객체

```
// 1번
Circle makeCircle(double  x, double y, double radius);

// 2번
Circle makeCircle(Point center, double radius);
```

\- 2-3개의 인수 일부를 독자적인 클래스 변수로 선언

➡ 변수를 묶어서 넘기기 위해서는 이름을 붙여야 하므로 개념을 표현하게 됨

 

인수 목록

```
void dyad(String name, Integer... args); //인수가 두개
```

\- 인수 목록은 하나의 항으로 취급

 

 

 

**7. 부수 효과❌**


\- 예상하지 못하게 클래스를 수정하면서 함수에서 여러가지 기능을 수행

▶️ 시간적 결합(temporal coupling), 순서 종속성(order dependency) 초래

 

\- 함수 이름에 분명하게 기능을 명시

 

\- 출력인수를 거의 사용하지 않음

```
//Bad Code
appendFooter(s); //s의 의미는?

//함수 선언부를 찾아서 s가 무슨 의미인지를 파악해야 함
-->public void appendFooter(StringBuffer report)

//Clean Code
report.appendFooter(); //this를 이용하여 함수 실행
```

 

 

 

**8. 명령과 조회 분리**

 

\- 함수는 1️⃣ 수행하거나 2️⃣ 답하거나 둘 중 하나만 해야함

ex) 객체 상태 변경 or 객체 정보 반환

 

Bad Code

```
public boolean set(String attribute, String value);

//--------//

if (set ("username", "unclebob"))
```

\- 함수 호출로 봐서 코드가 모호

\- set 함수가 username을 unclebob로 되어있는지 확인하는 코드인지, 셋팅을 하는 코드인지 알 수 없음

 

Clean Code

\- 명령과 조회를 분리

```
if (attributeExists("username")){
	setAttribute("username", "unclebob");
}
```

 

 

 

**9. 오류 코드보다 예외 사용**

 

\- try/catch는 별도 함수로 사용

 

\- 정상 동작과 오류처리 동작 분리

```
public void delete(Page page){
    try{
    	deletePageAndAllReferences(page); //실제 페이지를 제거하는 함수
    }
    catch (Exception e){
    	logError(e);
    }
}
```

\> 모든 오류 처리는 delete

\> 실제 행동은 deletePageAndAllReferences가 실행

 

\- 오류도 한 가지 동작만 사용

 

Bad Code

 



![img](https://k.kakaocdn.net/dn/besh0a/btri853NFnw/6INqPvkKInEGD5qJwnybX1/img.png)



\- 오류 코드 사용 시, 오류를 바로 처리해야 함

 

\- 중첩되는 문제 발생

 

 

Clean Code



![img](https://k.kakaocdn.net/dn/DPrFt/btri5Hiz8E9/ILY6K2A91naMgyqFGKO150/img.png)



\- 코드가 간편해짐

 

*Erro.java*

```
public enum Error{
	OK,
    INVALID,
    NO_SUCH,
    LOCKED,
    OUT_OF_RESOURCES,
    WAITING_FOR_EVENT;
}
```

\- 오류 코드 정의

\- 오류코드 대신 예외를 사용하면 재컴파일/재배치 없이 새 예외 클래스 추가 가능

 

 

 

**10. 중복 금지**

 

\- 부모 클래스를 이용하여 중복을 없앰

 

\- 구조적 프로그래밍, AOP, COP 등 중복 제거 전략

> **구조적 프로그래밍**
> \* 함수가 클 때만 이익을 제공하므로 작을 때는 아래 규칙을 지키지 않아도 됨
> \- 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 함 (return문 하나)
> \- 루프 안에 break, continue 사용❌
> \- goto는 절대 사용❌



---

## 4장, 주석

주석은 코드로 의도를 표현하지 못해서, 실패를 만회하기 위해서 사용함

> 🔴 **주석은 필요 악** 🔴
> \- 주석을 유지/보수하기 어려움
> \- 주석이 코드를 항상 따라가지 않음
> \- 주석이 부정확한 고아가 되는 사례가 많음
> \- 부정확한 주석은 없는 주석보다 훨씬 나쁨

 

**1. 주석은 나쁜 코드를 보완하지 못함**

 

\- 주석을 추가하는 이유: 코드 품질이 나쁘기 때문

 

 

**2. 코드로 의도를 표현**



![img](https://k.kakaocdn.net/dn/1R0Wi/btrjky6dsbX/ANcjIGErNhRtmSeLnHbsAK/img.png)



\- 주석을 사용하지 않고 코드로 표현

 

 

**3. 좋은 주석**

 

\1) 법적인 주석 ex. 저작권 정보

 

\2) 정보를 제공하는 주석 ex. 정규표현식의 시간과 날짜

 

\3) 의도를 설명하는 주석

 

\4) 의미를 명료하게 밝히는 주석 ex. 모호한 인수나 반환 값

```
if(a.compareTo(a) == 0){} // a == a

if(a.compatreTo(ab) == 0) // ab == ab
```

 

\5) 결과를 경고하는 주석

 

\6) TODO 주석

 

\7) 중요성을 강조하는 주석

 

\8) 공개 API의 Javadocs

 

 

**4. 나쁜 주석**

 

1) 주절거리는 주석

```
try{
	...
}
catch(Exception e){
	// 속성 파일이 없다면 기본값을 모두 메모리로 읽어들였다는 의미다.
}
```

\- catch의 주석을 해석하기 위해 다른 코드를 봐야함

 

2) 같은 이야기를 중복하는 주석

```
// closed가 false면 에러를 던진다.
if(!closed)
    throw new Exception("에러");
```

 

3) 오해할 여지가 있는 주석

 

4) 의무적으로 다는 주석

```
/**
*
* @param title CD 제목
* @param author CD 저자
* @param tracks CD 트랙 숫자
*/
```

 

5) 이력 기록

\- 혼란 가중

 

6) 새로운 정보를 제공하지 못하는 주석 (= 중복)

 

7) 무서운 잡음

\- 복붙 오류(잘못된 정보)

 

8) 함수나 변수로 표현할 수 있을 경우 주석❌

 

9) 위치를 표시하는 주석

```
// Action /////////////////
```

\- 잡음

\- 드물게 사용

 

10) 닫는 괄호에 다는 주석

\- 함수를 줄여서 해결

 

11) 공로를 돌리거나 저자를 표시하는 주석

 

12) 주석으로 처리한 코드

\- 쓸모 없는 코드가 점차 쌓여감

 

13) HTML 주석

\- HTML은 IDE에서 읽기 힘듦

 

14) 전역 정보

\- 주석을 달 때, 주석 근처에 있는 코드만 사용

\- 전반적인 내용을 기술X

 

15) 너무 많은 정보

 

16) 모호한 관계

\- 주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야함

\- 주석 자체가 다시 설명을 요구하면 안됨

 

17) 함수 헤더

\- 짧은 함수에는 긴 설명이 필요 없음

 

18) 비공개코드에서 javadocs 주석은 필요하지 않음

 

19) 예제

\- 중복

 

 

결론: 주석은 중복 없이, 필요한 것만, 간단하게



---

## 5장, 형식 맞추기

코드의 형식을 맞추기 위해 간단한 규칙을 정하고 따라야 함

 

 

**1. 형식을 맞추는 목적**

 

\- 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 영향을 미침

 

\- 원할한 소통

 

 

**2. 적절한 행 길이 유지**

 

\- 자바 파일 크기 = 클래스 파일 크기

 

\- 500줄을 넘지 않고 대부분 200줄 정도인 파일로 커다란 시스템을 구축 할 수 있음

ex. JUnit, FitNesse, Time and Money는 상대적으로 파일 크기가 작고, 200줄 미만임

 

 

\1) 신문 기사처럼 작성

 

\- 아래로 내려갈수록 세세한 사실이 보이도록

 

\- 이름: 간단하고 설명이 가능하게

 

\- 첫 부분에는 고차원 개념과 알고리즘 설명

 

\- 아래로 내려갈수록 의도를 세세하게 묘사

 

 

\2) 개념은 빈 행으로 분리

 

\- 코드는 ➡️, ⬇️ 방향으로 읽힘

 

\- 각 행: 수식, 절

 

\- 행 묶음: 완결된 생각 하나를 표현 --> 📌빈 행을 넣어 분리

 

 

\3) 세로 밀집도

 

\- 연관성: 서로 밀접한 코드 행은 세로로 가까이 놓여야 함

```
//1
public class Example{

    /**
     * 의미 없는 주석
     */

    private String className;

    /**
     * 의미 없는 주석
     */

    private List<Property> property = new ArrayList<>();
    public void addProperty(Proterty property){
         ...
    }
}


//2
public class Example{

    private String className;
    private List<Property> property = new ArrayList<>();
    public void addProperty(Proterty property){
         ...
    }
}
```

\- 1과 2를 비교했을 때, 1은 2에 비해 변수2개, 함수1개라는 포인트가 눈에 들어오지 않음

 

 

\4) 수직 거리

 

\- 함수가 어디에 있는지 찾고 기억하기가 어려움 ▶️ 서로 밀접한 개념은 세로로 가까이 두어야 함 ‼️단, 같은 파일일 것 --> protected 변수❌

 

\- 변수 선언: 사용하는 위치에 최대한 가까이

> **지역 변수**
> \- 각 함수의 맨 처음에 선언
>
> **루프 제어 변수**
> \- 루프문 내부에 선언
>
> **함수가 긴 경우
> **블록 상단이나 루프 직전에 변수 선언
>
> **인스턴스 변수(private static int num ...)
> **클래스 맨 처음에 선언, 중간에 두지 않음
> 변수 간에 세로로 거리를 두지 않음

 

\- 함수 선언

> **종속 함수**
> 한 함수가 다른 함수를 호출하면 두 함수는 세로로 가까이 배치
> 호출하는 함수를 호출되는 함수보다 먼저 배치

 

\- 개념적 유사성: 개념적인 친화도가 높을수록 코드를 가까이 배치

ex. 종속성, 변수와 변수를 사용하는 함수



![img](https://k.kakaocdn.net/dn/d5avim/btrjjMw49py/cYauzrJoma6Da9XNJNG7z1/img.png)



➡️ 명명법이 같고, 기본 기능이 유사하고 간단함 --> 종속 관계가 없어도 가까이 배치

 

 

\5) 세로 순서

 

\- 호출하는 함수를 호출되는 함수보다 먼저 선언

 

\- 가장 중요한 개념을 가장 먼저 표현

 

\- 세세한 사항은 가장 마지막에 표현

 

 

**3. 가로 형식 맞추기**

 

\- 120자 정도로 행 길이 제한

 

\1) 가로 공백과 밀집도

 

\- 공백을 이용하여 밀접한 개념과 느슨한 개념 표현

```
//공백을 넣어서 할당 연산자 강조
total += sum;

//함수 이름과 이어지는 괄호에 사이에 공백❌: 함수와 인수가 밀접하기 때문
recordWidestLine(lineSize);

//인수가 여러 개인 경우, 강조를 위해 공백
addLine(lineSize, lineCount);

// 수식의 경우 연산자 우선순위 표시
(-b - Math.sqrt(determinant)) / (2*a);
```

 

\2) 가로 정렬

 

\- 정렬하지 않으면 중대한 결함을 찾기가 오히려 더 쉬움

 

 

\3) 들여쓰기

 

\- 짧은 if, while 등 짧은 함수에서 들여쓰기를 무시하면 안됨

 

 

\4) 가짜 범위

 

\- 빈 while 문이나 for 문: 빈 블록을 올바로 들여쓰고 괄호로 감싸야 함 --> 세미콜론을 새 행에다가 넣어서 하면 눈에 띔

```
while( ... )
; // 새 행으로 while 표시
```



---

## 6장, 객체와 자료구조

변수를 비공개(private)로 정의하는 이유: 변수에 의존하지 않게 만들기 위해

 

그렇다면 왜 get, set을 사용하여 공개(public)할까?

 

 

**1. 자료 추상화**

 

\- 추상 인터페이스를 제공하여 사용자가 구현을 모른 채 자료의 핵심을 조작 할 수 있어야 함

 

\- 자료를 세세하게 공개하기 보다 추상적인 개념으로 표현

 

 

Bad Code

```
public class Point{
    public double x;
    public double y;
}
```

\> 구현을 외부로 노출하는 함수 ( private로 선언하더라도 get, set을 이용하면 외부에 노출하는 것과 마찬가지)

 

 

Clean Code

```
public interface Point{
    double getX();
    double getY();
    void setCartesian(double x, double y);
    double getR();
    double getTheta();
    void setPolar(double r, double theta);
}
```

\> 자료구조를 명백하게 표현

 

\> 좌표를 읽을 때, 각 값을 개별적으로 읽어야 함

 

 

 

**2. 자료/객체 비대칭**

 

\- 객체 = 추상화 뒤로 자료를 숨긴 채 함수만 공개

\- 자료구조 = 자료를 그대로 공개, 별다른 함수 제공 X

 

\- 자료구조를 사용하는 절차적 코드는 기존 자료 구조를 변경하지 않고 새 함수를 추가하기 쉬움

▶️ 새로운 자료 구조를 추가하기 어려움: 모든 함수를 고쳐야 함

 

\- 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉬움

▶️ 새로운 함수를 추가하기 어려움: 모든 클래스를 고쳐야 함

 

📌 때로는 절차지향 코드가 적합한 상황도 있다.

 

 

 

**3. 디미터 법칙: 모듈은 자신이 조작하는 객체의 속사정을 몰라야한다.**

 

\- 디미터 법칙이 어긋난 코드

 

\1) 기차 충돌 코드

```
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```

\> 기차처럼 늘어지는 코드는 조잡하다고 여겨짐

 

\> 각각의 함수가 어떤 객체를 리턴하는지 알 수 없음

 

Clean Code

```
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```

\> 각각 함수가 어떤 객체를 리턴하는지 확실하게 알 수 있음

 

\> 만약 ctxt, option, ScratchDir이 자료구조라면 노출하는 것이 맞음

> 💡 그러나 자료 구조가 아닌 이유
>
> \- 자료구조는 함수 없이 공개 변수만 포함
>
> ```
> //자료구조일 경우
> finalt String outputDir = ctxt.options.scratchDir.absolutePath;
> ```
>
>  

 

 

\2) 잡종 구조: 절반은 객체, 절반은 자료 구조인 구조

 

 

\3) 구조체 감추기

 

\- 왜 dir의 절대 경로가 필요한가? ➡️ 임시 파일을 생성하기 위해

 

\- ctxt가 절대 경로를 가져오지 않고, 임시 파일 생성을 하면 해결할 수 있음

 

 

 

**4. 자료 전달 객체(DTO)**

 

\- 자료 구조체(DTO): 공개 변수만 있고 함수가 없는 클래스

\> 데이터베이스에 저장된 가공되지 않은 정보를 애플리케이션 코드에서 사용할 객체로 변환하는 단계에서 가장 처음 사용하는 구조체

 

\- 자료 구조체 = 빈(bena): private 변수를 조회/설정 함수로 조작

 

\- 활성 레코드: DTO의 특수한 형태

\> 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료구조

\> save, find와 같은 탐색 함수도 제공



---

## 7장, 오류 처리

\- 잘못된 것을 바로 잡을 책임

 

 

**1. 오류 코드보다 예외를 사용**

 

\- 오류 코드를 사용하면 함수를 호출한 즉시 오류를 확인해야 함

 

\- 예외를 던지면 호출자의 코드가 깔끔해짐

 

 

 

**2. Try-Catch-Finally 문부터 작성**

 

\- 예외 프로그램 안에 범위 정의

 

\- try 블록에 들어가는 코드를 실행하면서 어느 시점에서든 실행이 중단된 후 catch 블록을 넘어갈 수 있음

 

\- try-catch 블록은 프로그램 상태를 일관성 있게 유지해야 함

▶️ try 블록에서 생기는 일들에 대해 호출자가 기대하는 상태를 정의하기 쉬움

 

\- 단위 테스트를 구현할 때, 강제로 예외를 일으키는 테스트케이스를 작성하여 try-catch문 구현 진행

 

 

 

**3. 미확인(unchechked) 예외를 사용**

 

\- 확인된 예외는 OCP(Open Closed Principle: 개방 폐쇄의 원칙, 기존 코드를 변경하지 않고 기능을 추가하는 것)을 위반함

\> catch 블록이 세 단계 위에 있으면 모든 메소드를 고쳐야 함

 

 

 

**4. 예외에 의미를 제공**

 

\- 예외를 던질 때 전후 상황을 충분히 덧붙여야 함

 

\- 오류 메시지에 정보를 담아 예외와 함께 던짐, 실패한 연산 

 

 

 

**5. 호출자를 고려해 예외 클래스 정의**

 

\- 오류를 정의할 때 가장 중요한 관심사는 오류를 잡아내는 방법이어야 함

 

\- 외부 라이브러리가 던지는 예외를 모두 잡는 tray-catch문은 과연 좋은 방법일까?

\> 호출하는 라이브러리 API를 감싸, 하나의 예외 코드만 반환하면 됨

\> 반복되는 코드를 줄여야 함

\> e.getMessage()를 이용하여 에러 던지기

 

\- 감싸기 방법을 사용

\> 특정 업체가 API를 설계한 방식에 발목 잡히지 않음

 

 

 

**6. 정상 흐름을 정의**

 

\- 클래스나 객체가 예외적인 상황을 캡슐화 하여 처리

 

 

 

**7. null 반환❌**

```
if(item != null){
	...
}
```

\- null 체크하는 것을 까먹으면 문제가 생길 가능성이 큼

 

\- 외부 API가 null을 반환하면 감싸기 메서드로 구현하여 예외를 던지거나 특수사례깩체를 반환해야 함

 

\- null 대신 빈 리스트 등을 반환

 

 

**8. null 전달❌**

 

\- 인수로 null을 전달하면 NullPointerException으로 문제가 발생할 수 있음

 

\- assert 문 사용

 

 

**결론**

 

\- Clean Code는 읽기도 좋아야 하지만 안정성도 필요함



---

## 8장, 경계

외부 코드를 우리 코드에 깔끔하게 통합하는 방법

 

 

**1. 외부 코드 사용하기**

 

\- 인터페이스 제공자와 인터페이스 사용자 사이의 경계

\> 인터페이스 제공자: 적용성을 최대한 넓힘

\> 사용자: 요구에 집중하기를 원함

> ex) java.util.Map: 제공하는 기능성과 유연성으로 인해 유용함 > 그러나 위험 ⬆
> \- Map을 사용하는 누구든 Map의 내용을 지울 수 있음

 

 

 

**2. 경계 살피고 익히기**

 

\- 타사 라이브러리의 사용법이 분명하지 않을 때

\> 문서를 읽어서 사용 ➡ 우리쪽 코드를 작성하여 라이브러리가 동작하는지 확인

 

\- 학습 테스트: 간단한 테스트 케이스를 작성하여 외부 코드를 먼저 익히기

 

 

 

**3. 아파치의 log4j**

 

\- 문서를 읽기전 테스트 케이스 작성

 

 

 

**4. 학습 테스트**

 

\- 학습 테스트에 드는 비용이 없음 -> 필요 지식을 확보하기 좋음

 

\- 학습 테스트로 패키지가 예상대로 도는지 검증

 

\- 새 버전이 호환되지 않으면 학습 테스트에서 사실을 바로 알아낼 수 있음

 

\- 패키지의 새 버전으로 이전하기 쉬워짐

 

 

 

**5. 아직 존재하지 않는 코드 사용**

 

\- 모르는 코드와 분리

 

\- 인터페이스를 구현하면 인터페이스를 전적으로 통제하는 장점이 생김

 

\- 설계를 잘 하면 테스트도 편함

\> 외부 인터페이스에 대해 (정의되지 않았더라도) 필요한 코드를 정의

 

 

 

**6. 깨끗한 경계**

 

\- 소프트웨어 설계가 우수하면 변경에 많은 투자와 재작업이 필요하지 않음

 

\- 경계에 위치하는 코드는 깔끔하게 분리

 

\- 외부 패키지를 호출하는 코드를 가능하면 줄여서 경계를 관리함

 

\- 새로운 클래스로 경계를 감싸거나 ADAPTER 패턴을 사용해 우리가 원하는 인터페이스로 변환



---

## 9장, 단위 테스트

\- 코드가 제대로 도는지 확인하여, 지속가능하게 사용 가능한 테스트 코드를 작성하는 것이 중요

\> 테스트 케이스를 모두 구현하고 통과한 후, 다른 사람들에게 공개해야 함

 

\- 애자일과 TDD로 단위 테스트를 자동화하고 제대로 된 테스트 케이스를 작성해야 함

 

 

 

**1. TDD 법칙 세가지**

 

\1) 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않음

 

\2) 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트 작성

 

\3) 현재 실패하는 테스트를 통과할 정도로만 실제 코드 작성

 

\- 개발과 테스트가 대략 30초 주기로 묶임

 

\- 그러나 많은 테스트 코드는 심각한 관리 문제를 유발함

 

 

 

**2. 깨끗한 테스트 코드 유지**

 

\- '지저분해도 빨리'는 이후에 테스트케이스를 유지하고 보수하는 비용도 늘어나게 됨

\> 지저분한 테스트 코드는 테스트를 안하는 것보다 더 못함

 

\- 테스트 슈트가 없으면 자신이 수정한 코드가 제대로 도는지 확인 할 방법이 없음

💡 테스트는 반드시 필요하므로, 처음부터 깨끗하게 해야 함

 

 

*테스트는 유연성, 유지보수성, 재사용성을 제공함*

 

\- 테스트 케이스가 있으면 변경에 두려움이 없음

➡️ 변경은 잠정적인 버그를 이끌지만, 테스트 커버리자가 높을수록 변경에 대해 우려 없이 변경할 수 있음

 

 

 

**3. 깨끗한 테스트 코드**

 

💡 가독성이 가장 중요함

\> 명료성, 단숭성, 풍부한 표현형

 

\- 중복을 제거할 것

 

\- 테스트의 세 부분

\1) 테스트 자료 생성

\2) 테스트 자료 조작

\3) 조작한 결과가 올바른지 확인

 

 

*도메인에 특화된 테스트 언어(DSL)*

 

\- API 위에대 함수와 유틸리티를 구현한 후, 그 함수와 유틸리티를 사용

➡️ 테스트 코드에서 사용하는 특수 API가 됨

 

\- 자신의 코드를 좀 더 간결하고 표현력이 풍부한 코드로 리팩터링을 지속적으로 해야 함

 

 

*이중 표준*

 

\- 테스트 API 코드에 적용하는 표준은 실제 코드에 적용하는 표준과 다름

 

\- 실제 코드만큼 효율적일 필요는 없음

 

\- 실제 환경에서는 절대로 안되지만 테스트 환경에서는 문제가 없는 방식이 있음(보통 메모리나 CPU 효율 문제)

 

 

 

**4. 테스트 당 assert 하나**

 

\- 테스트를 두 개로 쪼개 각자 assert를 수행 -> 테스트 코드를 읽기 쉬워짐

 

\- Template Method 패턴을 사용하여 중복을 제거

\> given/when 부분을 부모 클래스에 두고 then 부분을 자식 클래스에 둠

\> 또는 완전히 독자적인 테스트 클래스를 만들어 @Before 함수에 given/when을, @Test에 then을 넣어서 작성

\> 그러나 assert문을 여러개 사용하는 것이 더욱 좋음

 

\- 필요에 따라 assert문을 여러개 사용, 그러나 최대한 줄이는 게 좋음'

 

 

*테스트 당 개념 하나*

 

\- 테스트 함수마다 한 개념만 테스트

\> 잡다한 개념을 연속적으로 테스트하는 긴 함수를 피함

 

\- 개념 당 assert 문 수를 최소로 줄이는 것이 좋음

 

 

 

**5. F.I.R.S.T**

\- 깨끗한 테스트의 다섯가지 규칙

 

\1) Fast 빠르게: 테스트는 빨리 돌아야 함, 자주 돌리지 못하면 문제를 착기 어려움

 

\2) Independent 독립적으로: 각 테스트는 서로 의존적이면 안됨, 의존적일 때, 실패 원인을 찾기 어려움

ex. 한 테스트가 다음 테스트의 실행 환경을 준비❌

 

\3) Repeatable 반복가능하게: 어떤 환경에서도 반복 가능해야 함

 

\4) Self-Vaildating 자가검증하는: 테스트는 Bool 값으로 결과를 내야 함, 성공 or 실패

\- 통과 여부를 알기 위해 로그 파일을 읽거나 비교하면 안됨

 

\5) Timely 적시에: 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현

\- 실제 코드를 구현한 다음에 테스트 코드를 만들면 실제 코드를 테스트하기 어려울 수 있음

 

 

**결론**

\- 테스트 코드는 지속적으로 깨끗하게 관리

 

\- 테스트 코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화함

 

\- 테스트 API를 구현하여 도메인 특화 언어 DSL을 만들어야 함



---

## 10장, 클래스

**1. 클래스 체계**

 

\- 클래스를 정의하는 표준 자바 관례: 추상화 단계로 순차적으로 내려감

정적(static), 공개(public) 상수 -> 정적 비공개(private) -> 비공개 인스턴스 변수 -> 공개 함수 -> 비공개 함수

 

 

*캡슐화*

변수와 유틸리티 함수는 가능한 숨기는 게 좋음

 

\- protected: 변수나 유틸리티 함수에 테스트 코드가 접근 가능하도록 허용

why? 테스트가 매우 중요하기 때문

 

\- 비공개 상태를 유지할 방법을 찾아야 함

 

 

**2. 클래스는 작아야 함**

 

\- 클래스나 함수는 항상 '작게'가 기본 규칙이다.

 

\- 클래스의 크기는 '책임'으로 나눔

ex. SuperDashboard는 약 70개의 method로 이루어짐: 책임이 너무 많음

 

\- 클래스 이름: 클래스의 책임을 기술

➡️ Processor, Manager, Super 등의 단어는 클래스에 여러 책임을 안기게 된 것

 

\- if, and, or, but을 사용하지 않아야 함

 

 

*단일 책임 원칙(Single Responsibility Principle, SRP)*

 

\- 클래스나 모듈을 변경할 이유가 단 하나 뿐이어야 함

 

\- '책임', 변경할 이유를 파악하려면 코드를 추상화 하기가 쉬워짐

 

\- 위 SuperDashboard는 버전 정보를 다루는 메서드를 따로 빼내서 독자적인 클래스를 만들 수 있음

 

\- 대부분 '돌아가는 프로그램'에 초점을 맞출 때, '깨끗하고 체계적인 소프트웨어'를 만들 수 있어야 함



 

\- 작은 클래스 여러 개로 이루어진 시스템이 더욱 바람직 함, 하나의 클래스에 하나의 책임만

 

 

*응집도(Cohesion)*

 

\- 응집도가 높은 클래스는 바람직하지 않음

 

\- 클래스는 인스턴스 변수가 작아야 함, 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 함

\> 모든 인스턴스 변수를 메서드마다 사용하는 클래스는 응집도가 높음

 

\- 응집도가 높은 클래스를 선호하는 이유: 클래스에 속한 메서드와 변소가 서로 의존하며 논리적인 단위로 묶이기 때문

\> 몇몇 메서드만이 사용하는 인스턴스 변수가 많아지면, 새로운 클래스로 쪼개서 응집도를 낮춰야 함

 

\- 응집도를 유지하면 작은 클래스가 여러개가 나옴

\> 큰 함수에 정의된 변수 넷을 사용하는 작은 함수를 쪼갤 때, 변수를 클래스 인스턴스 변수로 승격하는 경우가 생김 -> 인스턴스 변수가 늘어나게 되어 좋지 않음

 

\- 큰 함수를 지속적으로 작은 함수로 쪼개야 함

> ex. p179의 PrintPrimes.java
> \- 리팩터링을 하면서 프로그램 길이가 길어짐
> \1. 리팩터링한 프로그램은 좀 더 길고 서술적인 변수 이름 사용
> \2. 코드에 주석을 추가하는 수단으로 함수 선언과 클래스 선언을 활용
> \3. 가독성을 높이기 위해 공백과 형식을 추가
>
> \- 리팩터링 방법
> \1. 정확한 동작을 검증하는 테스트 슈트 작성
> \2. 한 번에 하나 씩 코드 변경
> \3. 코드를 변경하면서 테스트를 수행하여 프로그램과 동일하게 동작하는 지 확인

 

 

 

**3. 변경하기 쉬운 클래스**

 

\- 변경 할 때마다 시스템이 의도대로 동작하지 않을 위험을 깨끗한 시스템은 클래스를 체계적으로 정리하여 위험을 낮춤

 

\- 클래스에 많은 책임이 있을 때 -> extends를 이용하여 각 클래스를 기능 별로 단순하게 나눠야 함

🔗 상속

 

\- 새 기능을 수정하거나 기존 기능을 변경할 때 건드릴 코드가 최소인 시스템 구조를 만들어야 함

 

 

*변경으로부터 격리*

 

\- 구체적인 클래스: 상세한 구현(코드)를 포함

➡️ 구현이 바뀌면 위험에 빠짐

➡️ 테스트가 어려움

 

\- 추상 클래스: 개념만 포함 ➡️ 영향 최소화

 

\- 테스트가 가능할 정도로 시스템의 결합도를 낮춰서 유연성과 재사용성을 높혀야 함

 

\- 결합도가 낮음 = DIP(Dependency Inversion Principle) 원칙을 따르는 클래스 생성

💡DIP: 클래스가 상세한 구현이 아니라 추상화에 의존해야 함

 

\- 추상화로 구체적인 사실을 숨겨야 함

---

## 11장, 시스템

복잡성은 죽음이다.

 

 

**1. 소프트웨어 = 도시**

 

\- 도시를 세울 때, 혼자서 직접 관리하기는 어렵지만 각 분야를 관리하는 팀으로 나뉨

\> 작은 사항에 집중 할 수 있음

\> 추상화와 모듈화: '구성요소'가 효율적으로 돌아감

 

\- 소프트웨어에서도 낮은 추상화 수준에서 관심사를 분리해야함

 

\- 시스템 수준에서의 깨끗함 유지

 

 

**2. 시스템 제작과 시스템 사용 분리**

 

\- 제작(Construction)과 사용(Use)은 다르다.

\> 소프트웨어 시스템(애플리케이션 객체를 제작하고 의존성을 서로 연결)은 준비과정과 런타임 로직을 분리해야 함

 

\- 시작 단계: 관심사(Concern) 분리

 

Bad Code

```
//초기화 지연(Lazy Initialization) == 계산 지연(Lazy Evaluation)
public Service getService(){
    if(service == null){
        service = new MyServiceImple(...); // 모든 상황에서 적합한가?
    }
    retrun service;
}
```

*장점*

\- 실제로 필요할 때까지 객체를 생성하지 않아서 불필요한 부하가 걸리지 않음

\> 앱 시간 시작 빠름

 

\- 어떤 경우에도 null 포인터를 반환하지 않음

 

*단점*

\- getService 메서드가 MyServiceImple 생성자 인수에 명시적으로 의존

\> 의존성을 해결하지 않으면 컴파일이 되지 않음

 

\- 테스트 시 getService 메소드를 호출하기 전에 적절한 테스트 전용 객체(Test Double, Mock Object)를 ㄴervice 필드에 할당해야 함

 

\- 일반 런타임 로직에 객체 생성 소릭을 섞어서 모든 실행 경로를 테스트 해야 함

 

\- 책임이 둘 이상, SRP를 깨트림

 

\- 모든 상황에 MyServiceImpl이 적절한 지 알 수 없음

 

 

*결론*

\- 손쉬운 기법으로 모듈성을 깨서는 안됨

 

\- 객체를 생성하거나 의존성을 연결할 때, 설정 논리와 일반 실행 노릴를 분리해야 함

 

 

Clean Code

 

*1) Main 분리*

\- 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮김

 

\- 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정

 

\- main 함수에서 시스템에 필요한 객체를 생성 한 후 애플리케이션에 넘김

 

\- 모든 애플리케이션은 main이나 객체가 생성되는 과정을 모름

 

 

*2) 팩토리*

\- 객체가 생성되는 시점을 애플리케이션이 결정해야 함

\> ABSTRACT FACTORY 패턴 사용

 

\- 객체를 생성하는 코드는 애플리케이션이 알 수 없음

 

*3) 의존성 주입(Dependency Injection, DI)*

\- 제어의 역전(Inversion of Control, IoC) 기법을 의존성 관리에 적용한 메커니즘

\> 제어의 역전: 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘김, 새로운 객체는 넘겨받은 책임만 맡음

\> 단일 책임 원칙(SRP)를 지킴

 

\- 책임을 지기 위해 main이나 특수 컨테이너 사용

💡 또는 설정자(setter)나 메서드나 생성자 인수를 제공

\> 필요한 객체의 인스턴스를 만든 후 생성자 인수나 설정자 메서드를 사용해 의존성 설정

 

\- Spring Framwrok의 경우 자바 DI 컨테이너를 제공하여 의존성을 XML 파일에 정의

 

\- DI 컨테이너는 필요할 때까지 객체를 생성하지 않고, 계산 지연이나 최적화에 쓸 수 있는 팩토리를 호출 or 프록시 생성하는 방법 제공

\> 계산 지연 기법(최적화 기법)에서 이런 메커니즘 사용 가능

 

 

 

**3. 확장**

 

\- 사용자 스토리에 맞춰 시스템을 조정하고 확장해야 함(애자일)

 

\- 테스트 주도 개발(TDD), 리팩터링, 깨끗한 코드 = 시스템을 조정하고 확장하기 쉽게 만듦

 

\- 시스템 수준: 단순한 아키텍처를 복잡한 아키텍처로 조금씩 키울 수 없음

\> 관심사를 적절히 분리하면 소프트웨어 아키텍처는 점진적으로 발전할 수 있음

 

\- 비즈니스 논리가 덩치 큰 컨테이너와 밀접하게 결합되어 있으면, 독자적인 단위 테스트가 어려움

 

 

*횡단(Cross-cutting) 관심사*

\- 영속성과 같은 관심사는 애플리케이션의 자연스러운 객체 경계를 넘나드는 경향이 있음

▶️ 모든 객체가 전반적으로 동일한 방식을 이용

 

\- 영속성 프레임워크, 도메인 논리 모두 모듈화 가능

\> 두 영역이 세밀한 단위로 겹치는 문제 발생

 

*관점지향 프로그래밍(Aspect-Oriented Programming, AOP)*

\- 횡단 관심사에 모듈성을 확보하는 방법론

 

\- 관점(Aspect): 특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 함

 

\- 프로그래머가 영속적으로 저장할 객체와 속성을 선언한 후, 영속성 책임을 영속성 프레임워크에 위임 ➡️ AOP 프레임워크는 대상 코드에 영향을 미치지 않는 상태로 동작 방식 변경

 

 

 

**4. 자바 프록시**

 

\- 단순한 상황에 적합 ex. 개별 객체, 클래스에서 메서드 호출을 감싸는 경우

 

\- JDK에서 제공하는 동적 프록시 = 인터페이스만 지원

▶️ 클래스 프록시: CGLIB, ASM, Javassist 등 바이트 코드를 처리하는 라이브러리 사용 필요

 

ex. p203 Bank.java: 추상화를 위한 POJO(Plain Old Java Object) 구현

 

\- 프록시를 사용하면서 깨끗한 코드를 작성하기 어려움

 

\- 시스템 단위로 실행 지점을 명시하는 메커니즘을 제공하지 않음

 

\- 도구로 자동화 가능

 

 

 

**5. 순수 자바 AOP 프레임워크**

 

\- AOP, JBoos AOP 등 자바 프레임 워크는 내부적으로 프록시를 사용함

 

\- 스프링은 비즈니스 논리를 POJO로 구현함

▶️ POJO: 순수하게 도메인에 초점, 엔터프라이즈 프레임워크에 의존하지 않음, 테스트가 간단하고 쉬움

 

\- 설정 파일이나 API를 사용하여 필수적인 애플리케이션 기반 구조를 구현

▶️ 횡단관심사(영속성, 트랜잭션, 보안, 캐시, 장애조치) 등 포함

 

\- 프레임워크는 사용자가 모르게 프록시나 바이트코드 라이브러리를 사용하여 구현

 

\- DI 컨테이너의 구체적인 동작 제어



 

스프링 app.xml의 일부분



![img](https://k.kakaocdn.net/dn/bWo07D/btrj87lVY1B/J8CzlCCNmdX5hwwu0jwT0k/img.jpg)![img](https://k.kakaocdn.net/dn/vAq5B/btrj4mLdDOf/5jWagDz1K1dLLNk7DgBhO1/img.jpg)



\- 러시아의 인형과 같이 중첩되어 있는 모습

 

\- 자료 접근자 객체는 JDBC 드라이버 자료 소스로 프록시 되어잇음

 

\- 클라이언트는 Bank 객체에서 getAccount()를 호출한다고 생각하지만, 실제로는 Bank POJO의 기본 동작을 확장한 중첩 Decorator 객체 집합의 가장 외곽과 통신

 

📌 앱에서 DI 컨테이너에게 객체 요청시, 스프링 관련 자바 코드가 필요 없어, 스프링과 독립적임 -> 강한 결합 해제



 

\- XML: 읽기 어렵지만 설정 파일에 명시된 정책이 자동으로 생성되는 프록시나 관점 논리보다 단순

▶️ 애플리케이션의 영속성 정보는 필요하다면 XML에 모두 옮겨도 괜찮음

 

 

 

**6. AspectJ 관점**

 

\- 관심사를 분리하는 가장 강력한 도구

 

\- AspectJ: 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장, 새 사용법을 익혀야 하는 단점 존재

 

\- 애너테이션 폼: 순수 자바 코드에 자바5 애너테이션을 사용하여 관점 정의

 

 

 

**7. 테스트 주도 시스템 아키텍처 구축**

 

\- 애플리케이션 도메인 논리를 POJO로 작성하여 코드 수준에서 아키텍처 관심사 분리 -> 테스트 주도 아키텍처 구축 가능

 

\- BDUF(Big Design Up Front: 구현 시작 전, 앞으로 벌어질 모든 상황 설계 기법)를 추구하지 않아도 됨

▶️BDUF는 변경을 쉽사리 추구하기 어려움

 

\- 아주 단순하게 분리된 아키텍처는 결과물을 재빨리 출시한 후, 기반 구조를 추가하여 확장하여도 됨

 

\- 결과로 내놓을 시스템의 일반적인 구조도 생각해야 함

 

\- 최선의 시스템 구조

➡️ POJO 객체로 구현되는 모듈화된 관심사 영역으로 구성

➡️ 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용하여 통합

➡️ 테스트 주도 기법 적용

 

 

 

 

**8. 의사 결정 최적화**

 

\- 모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능

 

\- 가능한 마지막까지 결정을 미뤄, 최대한의 정보로 최선의 결정을 내리기

 

 

 

**9. 명백한 가치가 있을 때 표준을 현명하게 사용**

 

\- 과장되게 표장된 표준에 집착하지 않기 ex. EJB2는 표준이라는 이유로 많이 사용되었다.

 

 

 

**10. 시스템은 도메인 특화 언어가 필요**

 

\- DSL(Domain-Specific Language): 간단한 스크립트 언어나 표준 언어로 구현한 API, 도메인 전문가가 작성한 구조적인 산문처럼 읽힘

▶️ 좋은 DSL: 도메인 개념과 개념을 구현한 코드 사이에 존재하는 의사소통 간극을 줄임

▶️ 추상화 수준을 코드 관용구나 디자인 패턴 이상으로 끌어올림

▶️ 모든 추상화 수준과 모든 도메인을 POJO로 표현 가능

 

 

**결론**

 

\- 시스템 아키턱처는 깨끗해야 함, 나쁜 아키텍처는 도메인 논리를 흐리고 기민성을 떨어뜨림 ➡️ TDD가 제공하는 장점이 사라짐

 

\- 모든 추상화 단계에서 의도를 명확하게 표현

▶️ POJO 작성, 관점을 분리하여 관심사를 분리



---

## 12장, 창발성

켄트 벡이 제시한 단순한 설계 규칙 네가지가 소프트웨어 설계 품질을 크게 높여준다.

 

\1. 모든 테스트를 실행한다.

\2. 중복을 없앤다.

\3. 프로그래머 의도를 표현한다.

\4. 클래스와 메서드 수를 최소로 줄인다.

 

 

**1. 단순 설계 규칙 1: 모든 테스트를 실행하라**

 

\- 설계는 의도한 대로 돌아가는 시스템을 내놓아야 한다. 그러나 시스템이 의도한 대로 돌아가는지 검증할 간단한 방법이 없다면?

 

\- 테스트가 불가능한 시스템은 검증도 불가능하다. 테스트가 가능한 시스템을 만들려고 하면 설계 품질이 높아진다.

 

\- SRP(단일 책임 원칙)를 준수하는 클래스는 테스트가 훨씬 쉽다.

 

\- 결합도가 높으면 테스트케이스를 작성하기 어려움 > 테스트케이스에 맞춰 만들면 결합도가 낮고 응집력이 높아짐

 

 

 

**2. 단순한 설계 규칙 2~4: 리팩터링**

 

\- 코드를 추가할 때마다 설계를 조감

\> 새로운 코드가 설계 품질을 낮추면 깔끔하게 정리한 후, 테스트케이스를 돌려서 기존 기능을 깨뜨리지 않았다는 사실을 확인

 

\- 테스트케이스가 있으면 코드를 정리하면서 시스템이 깨질 걱정X

 

 

 

**3. 중복을 없애라**

 

\- 중복 = 추가 작업, 추가 위험, 풀필요한 복잡도

 

\- 구현 중복

Bad Code

```
int size() {}
boolean isEmpty() {}
```

 

Clean Code

```
boolean isEmpty(){
	return 0 == size();
}
```

 

\- Template Method 패턴을 적용하여 중복 제거

 

 

 

**4. 표현하라**

 

\- 소프트웨어 프로젝트 비용의 대다수는 장기적인 유지보수에 들어감

 

\1) 좋은 이름 선택하기

\2) 함수와 클래스 크기를 최대한으로 줄임

\3) 표준 명칭 사용

 \- 디자인 패턴: 의사소통과 표현력 강화가 목적

\4) 단위테스트케이스를 꼼꼼히 작성

 \- 클래스의 기능이 한 눈에 들어옴

 

 

 

**5. 클래스와 메서드 수를 최소한으로 줄임**

그러나 중복제거, 의도 표현, SRP 준수를 너무 지키면 오히려 코드가 더 어려워짐



---

## 13장, 동시성

동시성과 깔끔한 코드는 양립하기 어려움

 

여러 스레드를 동시에 돌리는 이유, 여러 스레드를 동시에 돌리면 왜 어려울까? 그리고 이러한 어려움에 대처하고 깨끗하게 코드는 어떻게 작성할 수 있을까?

 

 

**1. 동시성이 필요한 이유**

동시성: 결합(coupling)을 없애는 전략, 처리량(throughput) 개선

 

\- 무엇과 언제를 분리

ex. 단일 스레드: breakpoint를 정해서 디버깅하여 시스템 상태 파악

멀티 스레드: 구조적 관점에서 작은 협력 프로그램 여럿으로 보이게 되어 시스템 이해가 쉬워짐

 

ex. 서블릿

\- 컨테이너는 동시성을 부분적으로 관리: 웹 요청이 들어올 때, 웹 서버는 비동기식으로 서빌릿 실행, 서블릿 프로그래머는 웹 요청을 ㅗ간리하지 않아도 됨

 

\- 정보를 병렬적으로 처리

> *동시성의 오해*
> \1. 동시성은 항상 성능을 높여준다.
> \> 때로 성능을 높여준다. 일상적으로 발생하지는 않음
>
> \2. 동시성을 구현해도 설계는 변하지 않는다.
> \> 무엇과 언제를 구분하면 설계가 달라진다.
>
> \3. 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
> \> 동시수정, 데드락 등의 문제는?
>
> *
> 동시성의 사실
> *1. 부하를 유발
> \2. 복잡
> \3. 일반적으로 동시성 버그는 재현하기 어려움
> \4. 근본적인 설계 전략을 재고

 

 

**2. 동시성이 어려운 이유**

 

\- 두 스레드가 같은 변수를 동시에 참조할 때

\> 자바의 바이트코드 처리 방식에 의해 어떻게 처리가 되는 지를 알아야 함

\> 바이트코드 처리 방식까지 신경쓰기 어려움

 

 

 

**3. 동시성 방어 원칙**

 

\1) 단일 책임 원칙 SRP

** 동시성은 다른 코드와 분리 **

 

\- 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 함

 

\- 동시성은 복잡성 하나만으로 따로 분리할 이유가 충분 -> 다른 코드와 분리하여 구현

 

 

\2) 따름 정리(corollary): 자료 범위 제한

** 자료를 캡슐화하여 공유 자료를 최대한 줄임 **

 

\- 객체 하나를 공유하여 수정하면 스레드가 서로 간섭을 하여 예상하지 못하는 결과를 내놓음

 

\- 임계영역(critical section)을 synchronized 키워드로 보호

\> 임계영역 수를 줄이는 기술도 중요함

 

\- 임계영역을 빼먹을 경우 큰 문제 발생 가능성 ↑

 

 

\3) 따름 정리: 자료 사본 사용

 

\- 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 가장 좋음

\> 객체를 복사하여 읽기 전용으로 사용하기

 

\- 공유 객체를 비하면 코드가 문제를 일으킬 가능성이 낮아짐

 

 

\4) 따름 정리: 스레드는 가능한 독립적으로 구현하라

** 독자적인 스레드로, 가능하면 다른 프로세서에서 돌려도 괜찮도록 자료를 독립적인 단위로 분할 **

 

\- 다른 스레드와 자료를 공유하지 않고, 각 스레드는 클라이언트 요청 하나를 처리 -> 다른 스레드와 동기화할 필요가 없음

 

\- 모든 정보는 비공유 출처에서 가져오고 로컬 변수에 저장

 

 

**4. 라이브러리를 이해하라**

자바 5에서 스레드 코드 구현 시 고려 사항

 

\- 스레드 환경에 안전한 컬렉션: java.util.concurrent

\> ConcurrentHashMap: 동시 읽기/쓰기 지원, HashMap보다 빠름

\> p.233 참고

 

 

 

**5. 실행 모델을 이해하라**

| 한정된 자원 | 다중 스레드 환경에서 사용하는 자원, 크기나 숫자가 제한적     |
| ----------- | ------------------------------------------------------------ |
| 상호 배제   | 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우 |
| 기아        | 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다리는 상태 |
| 데드락      | 여러 스레드가 서로 끝나기를 기다림                           |
| 라이브락    | 락을 거는 단계에서 스레드가 서로를 방해, 스레드는 계속해서 진행하려 하지만, 공명(resonance)으로 인해 굉장히 오랫동안 진행하지 못함 |

 

*생산자-소비자*

\- 하나 이상 생산자 스레드가 정보를 생성해 버퍼나 대기열에 넣음

 

\- 하나 이상의 소비자 스레드가 대기열에서 정보를 가져와 사용

 

\- 생산자와 소비자가 사용하는 대기열은 한정된 자원

\> 생산자: 대기열에 빈공간이 있어야함 -> 빈 공간이 있을 때까지 기다림

\> 소비자: 대기열에 정보가 있어야함 -> 정보가 채워질때까지 기다림

 

\- 대기열에 관한 정보를 생산자와 소비자가 주고받아야 함

 

 

*읽기-쓰기*

\- 읽기 스레드: 공유 자원을 사용, 쓰기 스레드: 공유 자원을 갱신

 

\- 처리율을 강조하면 기아 현상이 생기거나 오래된 정보가 쌓임

\> 균형을 잡기가 히듦

 

 

*식사하는 철학자들*

\- 둥근 식탁의 철학자, 각 철학자 왼쪽에는 포크가 있을 때, 배가 고프면 양손에 포크를 집어서 먹야아 함

-> 누군가 포크를 사용중이면 다른 철학자는 먹을 수 없음

-> 자원 처리 문제

 

 

**6. 동기하는 메서드 사이 존재하는 의존성 이해**

** 공유 객체 하나에는 메서드 하나만 사용 **

 

\- 동기화하는 메서드 사이 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생김

 

\- 자바 언어는 개별 메서드를 보호하는 synchronized 개념 지원

\> 공유 클래스 하나에 동기화된 메서드가 여럿이라면 구현이 올바른지 확인해야 함

 

\- 공유 객체 하나에 여러 메서드가 필요한 상황 시 고려사항 세가지

\1) 클라이언트에서 잠금 - 클라이언트에서 첫 번째 메서드 호출하기 전에 서버를 잠금, 마지막 메서드를 호출할 때까지 잠금을 유지

\2) 서버에서 잠금 - 서버에다 "서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는" 메서드를 구현한다. 클라이언트는 이 메서드를 호출한다.



\3) 연결 서버 - 잠금을 수행하는 중간 단계를 수행하는 중간 단계를 생성한다. '서버에서 잠금'방식과 유사하지만 원래 서버는 변경하지 않는다.

 

 

 

**7. 동기화하는 부분을 작게 만들어라**

 

\- 자바에서 synchronized 키워드를 사용하면 락을 설정함

\> 같은 락으로 감싼 모든 코드 영역은 한 번에 한 스레드만 실행 가능

 

\- 락은 스레드를 지연시키고 부하를 가중시킴

 

\- 임계영역은 반드시 보호해야 함

 

 

 

**8. 올바른 종료 코드는 구현하기 어려움**

** 종료 코드를 개발 초기부터 고민하고, 동작하게 초기부터 구현해야 함 **

 

\- 영구적으로 돌아가는 시스템 구현과 잠시 돈 후 종료하는 시스템 구현 방법은 다름

 

 

 

**9. 스레드 코드 테스트**

** 문제를 노출하는 테스트 케이스 작성, 프로그램 설정과 시스템 설정 부하를 바꿔가며 자주 돌려야 함, 실패 시 원인을 추척하라 **

 

\- 테스트가 정확성을 보장하지는 않지만, 충분한 테스트는 위험을 낮춤

 

\- 고려할 사항이 많음

\1) 말이 안되는 실패 = 잠정적인 스레드 문제

\> 시스템 실패를 일회성으로 치부하지 말아라

 

\2) 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌아야 함

\> 스레드가 호출하는 POJO를 만만들어서 스레드 환경 밖에서 테스트

\> 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅X

 

\3) 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워넣을 수 있어야 함, 상황에 맞춰 조정하게 작성

\> 다양한 설정에서 실행할 목적으로 다른 환경에 넣을 수 있는 코드 구현

 

\4) 프로세서 수보다 많은 스레드, 다른 플랫폼에서 돌려보기

 

\5) 코드에 *보조코드*를 넣어 돌려서 강제로 실패 해보기

\> 코드가 실행되는 수천 가지 경로 중 아주 소수만 실패 -> 버그를 찾기가 어려움

\> 보조 코드를 추가해 실행되는 순서 바꿔보기 ex. Object.wait(), Object.slepp() ...

 

\- 스레드 순서에 따라 성공 영향을 미침

 

\- 방법: 직접 구현, 자동화

 

*보조코드*

▶️ 직접 구현하기

\- wait(), sleep(), yiel(), priority() 함수 추가

 

\- 배포 환경이 아니라 테스트 환경에서 보조 코드를 실행할 방법이 필요

 

\- 스레드를 전혀 모르는 POJO와 스레드를 제어하는 클래스로 프로그램을 분활하면 보조 코드를 추가할 위치를 찾기 쉬워짐

 

 

▶️ 자동화

\- AOP(Aspect-Oriented Framwork), CGLIB, ASM

 

\- 다양한 위치에 ThreadJigglePoint.jiggle() 호출

\> 무작위로 sleep이나 yield, nop 호출

 

\- 코드를 흔드는(jiggle) 것이 중요

 

 

 

**결론**

\1. 다중 스레드는 올바로 구현하기 어려움

 

\2. SRP 준수 -> POJO를 사용해 스레드를 아는 코드와 스레드를 모르는 코드를 분리

 

\3. 동시성 오류를 일으키는 잠정적 원인 이해

 

\4. 사용하는 라이브러리와 기본 알고리즘 이해

 

\5. 보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법

 

\6. 테스트 용이성 TDD 규칙 따르기



---

## 14장, 점진적인 개선

\- 출발은 좋았으나 확장성이 부족했던 모듈

 

\- 모듈을 개선하고 정리하는 단계: 위에서 아래로 자연스럽게 읽혀야 함

 

\- 깨끗한 코드를 짜기 위해서는 지저분한 코드를 먼저 짠 뒤에 정리를 해야 함

 

 

 

**점진적 개선**

\- 개선이라는 이름 아래 구조를 크게 뒤집는 행위는 프로그램을 망친다.

 

\- 테스트 주도 개발(TDD) 기법을 사용하여 시스템을 망가뜨리는 변경을 허용하지 않음

\> 한 번에 하나씩 고침, 테스트 케이스를 하나라도 실패하면 다음으로 넘어가지 않음

 

ex. 반복되는 코드를 함수로 옮길 때, 먼저 함수에 다 넣은 후, 파생 클래스를 만들어서 분산하고 이후에 추상화, set, get 등 함수를 만드는 등 단계를 나눠서 진행해야 함

\> 중간 중간에 테스트를 진행하면서 기능 검사 수행

\> 만든 함수 중, 삭제 해도 괜찮은 함수들을 삭제하고 테스트 진행

 

\- 변경 된 코드는 새로운 인수 유형을 추가하기 쉽고(변경이 적음), 나머지 시스템에 영향을 미치지 않음



---

15, 16장은 리팩토링 방법으로 생략한다

---

## 17장, 냄새와 휴리스틱

 

**주석**

*C1: 부적절한 정보*

\- 다른 시스템에 저장할 정보는 주석으로 적절하지 못함

ex) 소스코드 관리 시스템, 버그 추적 시스템, 이슈 추적 시스템 등

 

\- 변경 이력과 장황한 날짜는 소스 코드를 번잡하게 만듦

 

\- 작성자, 최종 수정일, SPR 번호등만 주석으로 삽입

 

 

*C2: 쓸모 없는 주석*

\- 오래된 주석, 엉뚱한 주석, 잘못된 주석 들은 빠르게 삭제

 

 

*C3: 중복된 주석*

\- 설명하는 주석 주의

ex) i++ // i 증가

 

 

*C4: 성의 없는 주석*

\- 작성 할 가치가 있으면 간결하고 명료하게 작성

 

 

*C5: 주석 처리된 코드*

\- 주석 처리된 코드는 즉각 지워버려야 함

 

 

 

**환경**

*E1: 여러 단계로 빌드*

\- 빌드는 간단히 한 단계로 끝나야 함

 

\- 소스코드 관리 시스템에서 이것저것 따로 체크아웃 ❌

 

\- 한 명령으로 전체를 체크하여 빌드

 

 

*E2: 여러 단계로 테스트*

\- 모든 단위 테스트는 한 명령으로 돌려야 함

 

\- 테스트는 빠르고 쉽고 명백해야 함

 

 

 

**함수**

*F1: 너무 많은 인수*

\- 함수에서 인수 개수는 작을 수록 좋음

 

 

*F2: 출력 인수*

\- 직관을 정면으로 위배

 

\- 함수에서 상태를 변경해야 하면 객체의 상태를 변경하여야 함

 

 

*F3: 플래그 인수*

\- boolean은 함수가 여러 기능을 수행한다는 증거

 

 

*F4: 죽은 함수*

\- 아무도 호출하지 않는 함수는 삭제

 

 

 

**일반**

*G1: 한 소스 파일에 여러 언어 사용*

\- 혼란스럽고 조잡한 경우가 많음

 

\- 하나의 소스 파일에는 하나의 언어만 사용

 

 

*G2: 당연한 동작 구현❌*

\- 최소 놀람의 원칙에 의거해 함수나 클래스는 다른 프로그래머가 당연하게 여길 동작과 기능 제공

ex) Day day = DayDate.StringToDay(String dayNanme); 에서, Monday는 Day.MONDAY, Day.MON, Day.mon 등 올바로 변환하는 것을 기대함

 

 

*G3: 경계를 올바로 처리하지 않음*

 

 

*G4: 안전 절차 무시*

\- 컴파일러 경고를 무시하지 말아야 한다

 

 

*G5: 중복*

중복을 제거하는 것이 가장 핵심

\- DRY(Don't Repeat Yourself) 원칙

 

\- 코드에서 중복을 발견할 때, 추상화할 기회로 간주

 

\- 중복된 코드를 하위 루틴이나 다른 클래스로 분리

 

\- switch/case나 if/else는 다형성으로 대체

 

\- 알고리즘이 유사하나 서로 코드가 다른 중복 > TEMPLATE METHOD 패턴이나 STRATEGY 패턴으로 중복 제거

 

 

*G6: 추상화 수준이 올바르지 못함*

\- 모든 저차원의 개념은 파생 클래스에 넣고, 고차원의 개념은 추상 클래스에 넣음

ex) 세부 구현과 관련된 상수, 변수, 유틸리티 함수는 기초 클래스에 넣으면 안됨

 

\- 기초클래스/파생 클래스, 소스파일/모듈/컴포넌트로 분리

 

 

*G7: 기초 클래스가 파생 클래스에 의존하는 경우*

\- 고차원 기초 클래스 개념을 저차원 파생 클래스 개념으로부터 분리해 독립성을 보장하기 위함

\> 기초 클래스는 파생 클래스를 아에 몰라야 함

 

 

*G8: 과도한 정보*

\- 잘 정의된 모듈은 인터페이스가 아주 작음

 

\- 자료, 유틸리티 함수, 상수, 임시변수를 모두 숨겨야 함

 

 

*G9:* 죽은 코드

\- 불가능한 조건을 확인하는 if, thorw문이 없는 try/catch 블록, 아무도 호출하지 않는 유틸리티 함수, switch/case문에서 불가능한 case 조건 등

 

\- 죽은 코드는 설계가 변해도 제대로 수행되지 않음

 

 

*G10: 수직 분리*

\- 변수와 함수는 사용되는 위치에 가깝게 정의

 

\- 지역 변수: 처음 사용하기 직전에 선언, 수직으로 가깝게 위치

 

\- 비공개 함수는 호출한 직후 바로 정의

 

 

*G11: 일관성 부족*

\- 유사한 개념은 같은 방식으로 구현

 

 

*G12: 잡동사니*

\- 비어있는 기본 생성자, 아무도 사용하지 않는 변수, 아무도 호출하지 않는 함수, 정보를 제공하지 못하느 주석 등 제거

 

 

*G13: 인위적 결합*

\- 서로 무관한 개념을 인위적으로 결합X

ex) enum, static: 특정 클래스에 속할 이유가 없음

 

\- 인위적인 결합은 직접적인 상호작용 없는 두 모듈 사이에서 일어남

 

 

*G14: 기능 욕심*

\- 메서드가 다른 객체의 참조자와 변경자를 사용해 그 객체 내용을 조작하지 않아야 함

 

 

*G15: 선택자 인수*

\- 선택자 인수(bool)는 목적을 기억하기 어렵고, 여러 함수를 하나로 조합함

 

 

*G16: 모호한 의도*

\- 코드를 짤 때는 의도를 분명하게 밝혀야 함

ex) 행을 바꾸지 않고 표현한 수식, 헝가리식 표기법, 매직 번호 등

 

 

*G17: 잘못 지운 책임*

\- 코드를 배치하는 위치 -> 최소 놀람 원칙 적용

 

 

*G18: 부적절한 static 함수*

\- 특정 인스턴스와 관련 없이 모두 사용한 경우 사용

 

\- 일반적으로 인스턴스 함수가 static 함수보다 더 좋음

 

 

*G19: 서술적 변수*

\- 서술적 변수 이름을 사용하면 해독하기 어려운 모듈이 쉽게 읽힘

 

 

*G20: 이름과 기능이 일치하는 함수*

```
Date newDate = date.add(5);
```

\- 함수 이름이 모호함

 

\- addDaysTo 또는 increaseByDays로 변경하여 명확하게 해야 함

 

 

*G21: 알고리즘을 이해하라*

\- 기능이 뻔히 보일 정도로 함수를 깔끔하고 명확하게 재구성

 

 

*G22: 논리적 의존성은 물리적으로 드러내라*

\- 한 모듈이 다른 모듈에 의존한다면 물리적인 의존성도 있어야 함

 

 

*G23: If/Else나 Switch/Case 대신 다형성을 사용*

 

 

*G24: 표준 표기법*

\- 표준을 설명하는 문서는 코드 자체로 충분해야 하며 별도 문서를 만들 필요가 없어야 함

 

 

*G25: 매직 숫자는 명명된 상수로 교체*

\- 코드에서 숫자를 사용하지 말라

ex) SECONDS_PER_DAY = 60;

 

*G26: 정확하라*

\- 검색 결과 중 첫 번째 결과만 유일한 결과로 간주하지 말아라

 

\- 조회 결과가 하나 뿐이면 하나인지 확실하게 해야함

 

 

*G27: 관례보다 구조를 사용*

\- 설계 결정 시, 규칙보다 관계를 사용

 

 

*G28: 조건을 캡슐화*

```
if(shouldBeDeleted(timer))

if(timer.hasExpired() && !timer.isRecurrent())
```

\- 위의 조건문이 더 좋음

 

 

*G29:부정 조건은 피해라*

 

 

*G30: 함수는 한 가지만 해야 함*

\- 여러 개로 나누기

 

*G31: 숨겨진 시간적 결합*

\- 시간적 결합은 숨기면 안됨

 

\- 함수 인수를 적절히 배치하여 함수가 호출되는 순서를 명백하게 나타내야 함

 

 

*G32: 일관성 유지*

\- 구조에 일관성이 없으면 바꿔도 된다고 생각함

 

 

*G33: 경계 조건 캡슐화*

 

 

*G34: 함수는 추상화 수준을 한 단계만 내려가야 함*

\- 함수 내 모든 문장은 추상화 수준이 동일해야 함

\> 함수 이름이 의미하는 작업보다 한 단계 낮아야 함

 

\- 함수에서 추상화 수준을 분리하면 앞서 드러나지 않았던 새로운 추상화 수준이 드러나는 경우가 많음

 

 

*G35: 설정 정보는 최상위 단계에 둬라*

 

 

*G36: 추이적 탐색을 피하라*

\- 디미터의 법칙: A가 B를 사용하고 B가 C를 사용해도 A가 C를 알아야 할 필요가 없음

\> 자신이 직접 사용하는 모듈만 알아야 함

 

 

 

**자바**

*J1: 긴 import 목록을 피하고 와일드 카드를 사용*

```
ex) import package.*;
```

\- 명시적인 import 문은 강한 의존성을 생성하지만, 와일드카드는 그러지 않음

 

 

*J2: 상수는 상속하지 않음*

\- import static package.*;를 통해 언어의 범위 규칙을 속이는 행위

 

 

*J3: 상수 대 Enum*

\- int보다 유연하고 서술적으로 강력한 도구

 

 

**이름**

*N1: 서술적인 이름을 사용하라*

\- 소프트웨어 가독성의 90%는 이름으로 결정함

 

 

*N2: 적절한 추상화 수준에서 이름을 선택*

\- 구현을 드러내는 이름 사용❌

 

 

*N3: 가능하다면 표준 명명법 사용*

\- 프로젝트에 유효한 이름의미가 담길 수록 독자가 코드를 이해하기 쉬움

 

 

**N4: 명확한 이름**

\- 길지만 모듈에서 한 번만 호출되면서 단점을 메꿈

 

 

*N5: 긴 범위는 긴 이름을 사용*

\- 이름 길이는 범위 길이에 비례해야 함

 

 

*N6: 인코딩을 피하라*

\- 이름에 유형 정보나 범위 정보를 넣으면 안됨

 

\- 접두어❌

 

 

*N7: 이름으로 부수 효과 설명*

\- 함수, 변수, 클래스가 하는 일을 모두 기술하는 이름으로 사용해야 함

 

 

 

**테스트**

*T1: 불충분한 테스트*

\- 테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트 해야 함

 

 

*T2: 테스트 커버리지 도구 사용*

\- 테스트가 빠뜨리지 공백을 알려줌

 

 

*T3: 사소한 테스트를 건너뛰지 마라*

 

 

*T4: 무시한 테스트는 모호함을 뜻함*

\- 불분명한 요구사항은 테스트케이스를 주석으로 처리하거나 테스트 케이스에 @Ignore를 붙여 표현

 

 

*T5: 경계 조건 테스트*

 

 

*T6: 버그 주변은 철저히 테스트*

\- 한 함수에서 버그를 발견했다면 근처에서 발견 할 가능성이 높음

 

 

*T7: 실패 패턴 살피기*

\- 테스트 케이스가 실패하는 패턴으로 문제 진단

 

 

*T8: 테스트 커버리지 패턴 살피기*

\- 통과하는 테스트가 실행하거나 실행하지 않는 코드를 살펴보면 실패하는 테스트케이스의 원인이 나타남

 

 

*T9: 테스트는 빨라야 함*